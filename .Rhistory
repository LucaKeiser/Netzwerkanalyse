cluster <- net_SR_reduced %>%
activate(nodes) %>%
mutate(group_edge_betweenness = group_edge_betweenness(),
group_fast_greedy = group_fast_greedy(),
group_infomap = group_infomap()) %>%
select(name,
parlamentarier_partei,
group_edge_betweenness,
group_fast_greedy,
group_infomap) %>%
arrange(group_edge_betweenness)
# Tidy Print
kable(cluster)
# Chunk 10
# Beachten: Um die Cluster darstellen zu können, muss das concaveman-Paket installiert werden
# install.packages("concaveman")
# Hinzufügen der Kantenattribute
set.seed(1245)
net_SR_reduced %>%
activate(nodes) %>%
mutate(group_fast_greedy = as.factor(group_fast_greedy())) %>%
ggraph(layout = "fr") +
geom_node_point(aes(color = parlamentarier_partei,
size = betweenness)) +
geom_node_text(aes(label = name),
repel = TRUE) +
geom_edge_link(aes(width = weight),
show.legend = FALSE) +
geom_mark_hull(aes(x = x, y = y, fill = group_fast_greedy, label = group_fast_greedy)) +
scale_size(range = c(5, 15)) +
scale_edge_width(range = c(0.1, 1)) +
scale_color_manual(values = c("FDP" = "cornflowerblue",
"Grüne" = "chartreuse2",
"M" = "darkorange",
"SP" = "brown1",
"SVP" = "chartreuse4",
"Parteilos" = "grey")) +
theme_graph() +
labs(title = "Ständerätliches Netzwerk anhand privater Organisationszugehörigkeit - Fruchtermannreingold",
subtitle = "Knotenattribute: Namen, Parteizugehörigkeit und Betweenness-Score\nKantenattribute: gemeinsame Einsitze/Mitgliedschaften\nClustering: Fast & Greedy",
color = "Partei",
caption = "Es werden lediglich Beziehung zwischen Mitgleider:innen unterschiedlicher Parteien visualisiert")
install.packages("concaveman")
# Chunk 1
library(tidyverse)
library(tidygraph)
library(igraph)
library(ggraph)
library(janitor)
library(data.table)
library(knitr)
library(ggforce)
# Einlesen des Datensatzes
doc <- read_delim(here::here("Data", "Lobbywatch", "cartesian_minimal_parlamentarier_interessenbindung.csv"))
# Wir interessieren uns nur die Ständerät:innen
# Zudem möchten wir lediglich ihre ausserparteilichen Verbindungen
doc_SR <- doc %>%
filter(parlamentarier_rat == "SR") %>%
filter(organisation_rechtsform != "Parlamentarische Gruppe")
parlamentarier <- doc_SR %>%
select(parlamentarier_id,
parlamentarier_name,
parlamentarier_partei) %>%
mutate(parlamentarier_partei = case_when(
is.na(parlamentarier_partei) ~ "Parteilos",
TRUE ~ as.character(parlamentarier_partei))) %>%
group_by(parlamentarier_name) %>%
distinct(parlamentarier_id,
.keep_all = TRUE) %>%
arrange(parlamentarier_id) %>%
rename("id" = parlamentarier_id) %>%
rename("name" = parlamentarier_name)
# Chunk 2
# Erstellen der Gruppen
groupings <- doc_SR %>%
select(parlamentarier_id,
organisation_id) %>%
mutate(parlamentarier_id = str_c(parlamentarier_id, "",
sep = "_")) %>% # Wird später gebraucht, um die einzelnen IDs wieder voneinander trennen zu können.
group_by(organisation_id, parlamentarier_id) %>%
distinct() %>%
summarise(sum = n())
setDT(groupings)
# N = Anahl geteilter Organisationsmitgliedschaften. In diesem Schritt erstellen wir das Kantenattribut.
ties_SR <- groupings[groupings, on = "organisation_id", allow.cartesian = TRUE][parlamentarier_id<i.parlamentarier_id, .N, .(pair = paste0(parlamentarier_id, i.parlamentarier_id))]
# Chunk 3
# Erstellen eines tidy-Datensatzes
ties_SR <- ties_SR %>%
separate(pair,
into = c("from", "to"),
sep = "_") %>%
rename("weight" = N) %>%
arrange(desc(weight))
#filter(weight >= 5) # Es werden nur Verbindungen zwischen Parlamentarier:innen verwendet, die in >= 5 gleichen Organisationen einsitzen.
# Wir wollen keine Intraparty-Edges, deshalb werden diese gelöscht.
# Intraparty bedeutet: Personen in derselben Partei werden nicht als Edge dargestellt.
non_interparty <- c()
# Der Loop schaut, ob zwei Nodes mit einer Verbindung derselben Partei angehören. Falls ja, dann wird der Index
# des Paares einer Liste hinzugefügt. Diese Liste wird dann aus unserem Datensatz entfernt.
for(i in 1:nrow(ties_SR)){
from <- ties_SR$from[i]
to <- ties_SR$to[i]
if(parlamentarier[parlamentarier$id == from,3] == parlamentarier[parlamentarier$id == to,3]){
non_interparty <- append(non_interparty,i)
}
}
ties_SR_reduced <- ties_SR[-non_interparty,]
# erstellen eines Tibbles mit angepassten Datentypen
ties_SR <- ties_SR %>%
as_tibble() %>%
mutate(from = as.numeric(from),
to = as.numeric(to))
ties_SR_reduced <- ties_SR_reduced %>%
as_tibble() %>%
mutate(from = as.numeric(from),
to = as.numeric(to))
# Knoten
parlamentarier
# Kanten
ties_SR
ties_SR_reduced
# Chunk 4
# erstellen des Netzwerkobjekts (tidygraph)
net_SR <- as_tbl_graph(ties_SR,
directed = FALSE) %>%
activate(nodes) %>%
mutate(id = as.numeric(name)) %>%
select(-name)
net_SR_reduced <- as_tbl_graph(ties_SR_reduced,
directed = FALSE)  %>%
activate(nodes) %>%
mutate(id = as.numeric(name)) %>%
select(-name)
# Chunk 5
# Generelle Netzwerkangaben
# Component
comp_sr <- count_components(net_SR)
comp_sr_red <- count_components(net_SR_reduced)
# Dichte
dens_sr <- edge_density(net_SR,
loops = FALSE)
dens_sr_red <- edge_density(net_SR_reduced,
loops = FALSE)
# Diameter
dia_sr <- diameter(net_SR,
directed = FALSE)
dia_sr_red <- diameter(net_SR_reduced,
directed = FALSE)
# Size
size_sr <- gsize(net_SR)
size_sr_red <- gsize(net_SR_reduced)
# Cliques
cliq_sr <- count_max_cliques(net_SR)
cliq_sr_red <- count_max_cliques(net_SR_reduced)
# Erstellen eines zusammenfassenden Dataframes für die Masszahlen
labels_df <- c("Components", "Density", "Diameter", "Size", "Cliques")
measurements_df <- data.frame(Measurement = labels_df,
`With Intraparty Connections` = c(comp_sr,dens_sr,dia_sr,size_sr,cliq_sr),
`Without Intraparty Connections` = c(comp_sr_red,dens_sr_red,dia_sr_red,size_sr_red,cliq_sr_red))
# Tidy Print
kable(measurements_df, caption = "Masszahlen der Netzwerke mit und ohne innerparteilicher Beziehungen")
# Chunk 6
# hinzufügen der Knotenattribute
net_SR_reduced <- net_SR_reduced %>%
activate(nodes) %>%
# Datentyp muss angepasst werden.
left_join(parlamentarier,
by = c("id"))
# Hinzufügen Zentralitätsmasse
net_SR_reduced <- net_SR_reduced %>%
activate(nodes) %>%
# Berechnung und standardisierung([0,1]) der Betweenness
mutate(degree = centrality_degree(),
betweenness = centrality_betweenness(),
closeness = centrality_closeness())
# Extrahierung der relevanten Zeilen
masszahlen <- net_SR_reduced %>%
select(name,
parlamentarier_partei,
degree,
betweenness,
closeness) %>%
arrange(desc(degree))
# Tidy Print
kable(masszahlen)
# Chunk 7
library(statnet)
# erstellen temporärer Objekte zur Zwischenspeicherung
temp_1 <- ties_SR_reduced %>%
left_join(parlamentarier, by = c("from" = "id")) %>%
select(name, weight) %>%
rename("from"  = name)
temp_2 <- ties_SR_reduced %>%
left_join(parlamentarier, by = c("to" = "id")) %>%
select(name) %>%
rename("to"  = name)
network_ties_SR_reduced <- cbind(temp_1, temp_2) %>%
relocate(from, to, weight)
# löschen der temporären Objekte
rm(temp_1, temp_2)
gc()
# erstellen eines network-Objekts
network_SR_reduced <- network(network_ties_SR_reduced,
type = "edgelist",
directed = FALSE)
# Identifizierung der Cutpoints
cutpoints_SR_reduced <- cutpoints(network_SR_reduced,
# graph for undirected graphs
mode = "graph",
return.indicator = TRUE)
# insegsamt wurden 9 Cutpoints gefunden
table(cutpoints_SR_reduced)
# Visualisierung
set.seed(1234)
gplot(network_SR_reduced,
gmode = "graph",
vertex.col = cutpoints_SR_reduced + 3,
vertex.border = cutpoints_SR_reduced + 3,
vertex.cex = 0.7,
edge.col = "grey90",
jitter = FALSE,
displaylabels = TRUE,
label.cex = 0.7,
label.pos = 5,
main = "Cutpoints im reduzierten Netzwerk der Stände:rätinnen",
)
# Chunk 8
bridges <- function(dat,
mode = "graph",
connected = c("strong", "weak")) {
# edgecount
e_cnt <- network.edgecount(dat)
if(mode == "graph") {
# get number of components
cmp_cnt <- components(dat)
b_vec <- rep(FALSE, e_cnt)
for(i in 1:e_cnt) {
dat2 <- dat
delete.edges(dat2, i)
b_vec[i] <- (components(dat2) != cmp_cnt)
}
}
else {
cmp_cnt <- components(dat,
connected = connected)
b_vec <- rep(FALSE, e_cnt)
for(i in 1:e_cnt) {
dat2 <- dat
delete.edges(dat2, i)
b_vec[i] <- (components(dat2,
connected = connected) != cmp_cnt)
}
}
return(b_vec)
}
network_SR_reduced_bridges <- bridges(network_SR_reduced)
# insgesamt wurden 8 Bridges gefunden
table(network_SR_reduced_bridges)
# Visualisierung
set.seed(1234)
gplot(network_SR_reduced,
gmode = "graph",
vertex.col = "grey90",
vertex.border = "grey90",
vertex.cex = 0.7,
edge.col = network_SR_reduced_bridges + 3,
jitter = FALSE,
displaylabels = TRUE,
label.cex = 0.7,
label.pos = 5,
main = "Bridges im reduzierten Netzwerk der Stände:rätinnen",
)
# Chunk 9
# Erstellen mehrerer Clusterings anhand dreier Algorithmen:
# Edge Betweenness, Fast Greedy & Infomap
cluster <- net_SR_reduced %>%
activate(nodes) %>%
mutate(group_edge_betweenness = group_edge_betweenness(),
group_fast_greedy = group_fast_greedy(),
group_infomap = group_infomap()) %>%
select(name,
parlamentarier_partei,
group_edge_betweenness,
group_fast_greedy,
group_infomap) %>%
arrange(group_edge_betweenness)
# Tidy Print
kable(cluster)
# Chunk 10
# Beachten: Um die Cluster darstellen zu können, muss das concaveman-Paket installiert werden
# install.packages("concaveman")
# Hinzufügen der Kantenattribute
set.seed(1245)
net_SR_reduced %>%
activate(nodes) %>%
mutate(group_fast_greedy = as.factor(group_fast_greedy())) %>%
ggraph(layout = "fr") +
geom_node_point(aes(color = parlamentarier_partei,
size = betweenness)) +
geom_node_text(aes(label = name),
repel = TRUE) +
geom_edge_link(aes(width = weight),
show.legend = FALSE) +
geom_mark_hull(aes(x = x, y = y, fill = group_fast_greedy, label = group_fast_greedy)) +
scale_size(range = c(5, 15)) +
scale_edge_width(range = c(0.1, 1)) +
scale_color_manual(values = c("FDP" = "cornflowerblue",
"Grüne" = "chartreuse2",
"M" = "darkorange",
"SP" = "brown1",
"SVP" = "chartreuse4",
"Parteilos" = "grey")) +
theme_graph() +
labs(title = "Ständerätliches Netzwerk anhand privater Organisationszugehörigkeit - Fruchtermannreingold",
subtitle = "Knotenattribute: Namen, Parteizugehörigkeit und Betweenness-Score\nKantenattribute: gemeinsame Einsitze/Mitgliedschaften\nClustering: Fast & Greedy",
color = "Partei",
caption = "Es werden lediglich Beziehung zwischen Mitgleider:innen unterschiedlicher Parteien visualisiert")
View(bridges)
View(bridges)
View(bridges)
View(bridges)
View(masszahlen)
View(cluster)
View(cluster)
View(ties_SR_reduced)
View(ties_SR_reduced)
View(bridges)
function(dat,
mode = "graph",
connected = c("strong", "weak")) {
# edgecount
e_cnt <- network.edgecount(dat)
if(mode == "graph") {
# get number of components
cmp_cnt <- components(dat)
b_vec <- rep(FALSE, e_cnt)
for(i in 1:e_cnt) {
dat2 <- dat
delete.edges(dat2, i)
b_vec[i] <- (components(dat2) != cmp_cnt)
}
}
else {
cmp_cnt <- components(dat,
connected = connected)
b_vec <- rep(FALSE, e_cnt)
for(i in 1:e_cnt) {
dat2 <- dat
delete.edges(dat2, i)
b_vec[i] <- (components(dat2,
connected = connected) != cmp_cnt)
}
}
return(b_vec)
}
View(masszahlen)
View(masszahlen)
View(masszahlen)
View(masszahlen)
View(masszahlen)
View(measurements_df)
View(bridges)
View(ties_SR_reduced)
View(groupings)
View(net_SR_reduced)
View(net_SR_reduced)
View(net_SR)
View(net_SR)
View(measurements_df)
View(measurements_df)
library(tidyverse)
library(tidygraph)
library(igraph)
library(ggraph)
library(janitor)
library(data.table)
library(knitr)
library(ggforce)
# Einlesen des Datensatzes
doc <- read_delim(here::here("Data", "Lobbywatch", "cartesian_minimal_parlamentarier_interessenbindung.csv"))
# Wir interessieren uns nur die Ständerät:innen
# Zudem möchten wir lediglich ihre ausserparteilichen Verbindungen
doc_SR <- doc %>%
filter(parlamentarier_rat == "SR") %>%
filter(organisation_rechtsform != "Parlamentarische Gruppe")
parlamentarier <- doc_SR %>%
select(parlamentarier_id,
parlamentarier_name,
parlamentarier_partei) %>%
mutate(parlamentarier_partei = case_when(
is.na(parlamentarier_partei) ~ "Parteilos",
TRUE ~ as.character(parlamentarier_partei))) %>%
group_by(parlamentarier_name) %>%
distinct(parlamentarier_id,
.keep_all = TRUE) %>%
arrange(parlamentarier_id) %>%
rename("id" = parlamentarier_id) %>%
rename("name" = parlamentarier_name)
parlamentarier <- doc_SR %>%
select(parlamentarier_id,
parlamentarier_name,
parlamentarier_partei) %>%
mutate(parlamentarier_partei = case_when(
is.na(parlamentarier_partei) ~ "Parteilos",
TRUE ~ as.character(parlamentarier_partei))) %>%
group_by(parlamentarier_name) %>%
distinct(parlamentarier_id,
.keep_all = TRUE) %>%
arrange(parlamentarier_id) %>%
rename("id" = parlamentarier_id) %>%
rename("name" = parlamentarier_name)
```{r message=FALSE, warning=FALSE}
# Erstellen der Gruppen
groupings <- doc_SR %>%
select(parlamentarier_id,
organisation_id) %>%
mutate(parlamentarier_id = str_c(parlamentarier_id, "",
sep = "_")) %>% # Wird später gebraucht, um die einzelnen IDs wieder voneinander trennen zu können.
group_by(organisation_id, parlamentarier_id) %>%
distinct() %>%
summarise(sum = n())
setDT(groupings)
# N = Anahl geteilter Organisationsmitgliedschaften. In diesem Schritt erstellen wir das Kantenattribut.
ties_SR <- groupings[groupings, on = "organisation_id", allow.cartesian = TRUE][parlamentarier_id<i.parlamentarier_id, .N, .(pair = paste0(parlamentarier_id, i.parlamentarier_id))]
# hinzufügen der Knotenattribute
net_SR_reduced <- net_SR_reduced %>%
activate(nodes) %>%
# Datentyp muss angepasst werden.
left_join(parlamentarier,
by = c("id"))
# Generelle Netzwerkangaben
# Component
comp_sr <- count_components(net_SR)
# N = Anahl geteilter Organisationsmitgliedschaften. In diesem Schritt erstellen wir das Kantenattribut.
ties_SR <- groupings[groupings, on = "organisation_id", allow.cartesian = TRUE][parlamentarier_id<i.parlamentarier_id, .N, .(pair = paste0(parlamentarier_id, i.parlamentarier_id))]
# N = Anahl geteilter Organisationsmitgliedschaften. In diesem Schritt erstellen wir das Kantenattribut.
ties_SR <- groupings[groupings, on = "organisation_id", allow.cartesian = TRUE][parlamentarier_id<i.parlamentarier_id, .N, .(pair = paste0(parlamentarier_id, i.parlamentarier_id))]
```{r message=FALSE, warning=FALSE}
# Erstellen eines tidy-Datensatzes
ties_SR <- ties_SR %>%
separate(pair,
into = c("from", "to"),
sep = "_") %>%
rename("weight" = N) %>%
arrange(desc(weight))
# Wir wollen keine Intraparty-Edges, deshalb werden diese gelöscht.
# Intraparty bedeutet: Personen in derselben Partei werden nicht als Edge dargestellt.
non_interparty <- c()
for(i in 1:nrow(ties_SR)){
from <- ties_SR$from[i]
to <- ties_SR$to[i]
if(parlamentarier[parlamentarier$id == from,3] == parlamentarier[parlamentarier$id == to,3]){
non_interparty <- append(non_interparty,i)
}
}
ties_SR_reduced <- ties_SR[-non_interparty,]
# erstellen eines Tibbles mit angepassten Datentypen
ties_SR <- ties_SR %>%
as_tibble() %>%
mutate(from = as.numeric(from),
to = as.numeric(to))
ties_SR_reduced <- ties_SR_reduced %>%
as_tibble() %>%
mutate(from = as.numeric(from),
to = as.numeric(to))
# Knoten
parlamentarier
# Kanten
ties_SR
ties_SR_reduced
```{r}
# erstellen des Netzwerkobjekts (tidygraph)
net_SR <- as_tbl_graph(ties_SR,
directed = FALSE) %>%
activate(nodes) %>%
mutate(id = as.numeric(name)) %>%
select(-name)
net_SR_reduced <- as_tbl_graph(ties_SR_reduced,
directed = FALSE)  %>%
activate(nodes) %>%
mutate(id = as.numeric(name)) %>%
select(-name)
## Masszahlen - gesamtes Netzwerk
Vergleich zwischen dem dichteren Netzwerk mitsamt innerparteilicher Edges und jenem, welches nur ausserparteiliche Edges darstellt.
# Generelle Netzwerkangaben
# Component
comp_sr <- count_components(net_SR)
comp_sr_red <- count_components(net_SR_reduced)
# Dichte
dens_sr <- edge_density(net_SR,
loops = FALSE)
dens_sr_red <- edge_density(net_SR_reduced,
loops = FALSE)
# Diameter
dia_sr <- diameter(net_SR,
directed = FALSE)
# Size
size_sr <- gsize(net_SR)
size_sr_red <- gsize(net_SR_reduced)
# Cliques
cliq_sr <- count_max_cliques(net_SR)
cliq_sr_red <- count_max_cliques(net_SR_reduced)
# Erstellen eines zusammenfassenden Dataframes für die Masszahlen
labels_df <- c("Components", "Density", "Diameter", "Size", "Cliques")
measurements_df <- data.frame(Measurement = labels_df,
`With Intraparty Connections` = c(comp_sr,dens_sr,dia_sr,size_sr,cliq_sr),
`Without Intraparty Connections` = c(comp_sr_red,dens_sr_red,dia_sr_red,size_sr_red,cliq_sr_red))
# Tidy Print
kable(measurements_df, caption = "Masszahlen der Netzwerke mit und ohne innerparteilicher Beziehungen")
measurements_df <- data.frame(Measurement = labels_df,
`With Intraparty Connections` = c(comp_sr,dens_sr,dia_sr,size_sr,cliq_sr),
`Without Intraparty Connections` = c(comp_sr_red,dens_sr_red,dia_sr_red,size_sr_red,cliq_sr_red))
