op <- par(mar = rep(0, 4),mfrow=c(1,2))
plot(net_SR_2, mode = "circle")
plot(net_SR_2, mode = "fruchtermannreingold")
par(op)
data(net_SR_2)
op <- par(mar = rep(0, 4),mfrow=c(1,2))
plot(net_SR_2, mode = "circle", main = "circle")
plot(net_SR_2, mode = "fruchtermannreingold", main='fruchtermannreingold')
par(op)
plot(net_SR_2, layout = layout.circle, main = "circle")
data(net_SR_2)
op <- par(mar = rep(0, 4),mfrow=c(1,2))
plot(net_SR_2, layout = layout.circle, main = "circle")
plot(net_SR_2, layout = layout.fruchtermann.reingold, main='fruchtermannreingold')
par(op)
data(net_SR_2)
op <- par(mar = rep(0, 4),mfrow=c(1,2))
plot(net_SR_2, layout = layout.circle, main = "circle")
plot(net_SR_2, layout = layout.fruchterman.reingold, main='fruchtermannreingold')
par(op)
help(layout)
data(net_SR_2)
op <- par(mar = rep(0, 4),mfrow=c(1,2))
plot(net_SR_2, layout = layout.circle, main = "circle", Labels = NULL)
plot(net_SR_2, layout = layout.fruchterman.reingold, main='fruchtermannreingold')
par(op)
data(net_SR_2)
op <- par(mar = rep(0, 4),mfrow=c(1,2))
plot(net_SR_2, layout = layout.circle, main = "circle", Labels = NA)
plot(net_SR_2, layout = layout.fruchterman.reingold, main='fruchtermannreingold')
par(op)
data(net_SR_2)
op <- par(mar = rep(0, 4),mfrow=c(1,2))
plot(net_SR_2, layout = layout.circle, main = "circle", Labels = FALSE)
plot(net_SR_2, layout = layout.fruchterman.reingold, main='fruchtermannreingold')
par(op)
data(net_SR_2)
op <- par(mar = rep(0, 4),mfrow=c(1,2))
plot(net_SR_2, layout = layout.circle, main = "circle", vertex.label=NA)
plot(net_SR_2, layout = layout.fruchterman.reingold, main='fruchtermannreingold')
par(op)
data(net_SR_2)
op <- par(mar = rep(0, 4),mfrow=c(1,2))
plot(net_SR_2, layout = layout.circle, main = "circle", vertex.label=NA)
plot(net_SR_2, layout = layout.fruchterman.reingold, main='fruchtermannreingold', vertex.label=NA)
par(op)
data(net_SR_2)
op <- par(mar = rep(0, 4), mfrow=c(1,2), ma=c(0,0,2,0))
plot(net_SR_2, layout = layout.circle, main = "circle", vertex.label=NA)
plot(net_SR_2, layout = layout.fruchterman.reingold, main='fruchtermannreingold', vertex.label=NA)
par(op)
data(net_SR_2)
op <- par(mar = rep(0, 4), mfrow=c(1,2), oma=c(0,0,2,0))
plot(net_SR_2, layout = layout.circle, main = "circle", vertex.label=NA)
plot(net_SR_2, layout = layout.fruchterman.reingold, main='fruchtermannreingold', vertex.label=NA)
par(op)
data(net_SR_2)
op <- par(mmfrow=c(1,2), oma=c(0,0,2,0))
plot(net_SR_2, layout = layout.circle, main = "circle", vertex.label=NA)
plot(net_SR_2, layout = layout.fruchterman.reingold, main='fruchtermannreingold', vertex.label=NA)
par(op)
?par
data(net_SR_2)
op <- par(mar = rep(0,0,2,0), mfrow=c(1,2))
plot(net_SR_2, layout = layout.circle, main = "circle", vertex.label=NA)
plot(net_SR_2, layout = layout.fruchterman.reingold, main='fruchtermannreingold', vertex.label=NA)
par(op)
data(net_SR_2)
op <- par(mar = c(0,0,2,0), mfrow=c(1,2))
plot(net_SR_2, layout = layout.circle, main = "circle", vertex.label=NA)
plot(net_SR_2, layout = layout.fruchterman.reingold, main='fruchtermannreingold', vertex.label=NA)
par(op)
network_gg(net_SR_2,"fruchtermanreingold", 0)
library(statnet)
library(GGally)
library(ggpubr)
set.seed(1234)
# Für den Plot werden die ofiziellen Parteifarben vergeben
# ggnet2 akzeptiert keine Hex-Codes, deshalb werden Annäherungen verwendet
colors_party = c("FDP" = "cornflowerblue",
"Grüne" = "chartreuse",
"M" = "darkorange",
"SP" = "brown1",
"SVP" = "chartreuse4")
# Funktion wird für die Reduktion von Redundanzen verwendet
network_gg <- function(network,mode,gewichtet){
if(gewichtet == 1){
plot <- ggnet2(network,
mode = mode,
color = "parlamentarier_partei",
palette = colors_party,
size = 7,
label = T,
label.alpha = .7,
vjust = -1,
edge.size = "weight",
legend.position = "bottom") +
labs(title = "Parlamentarisches Netzwerk des Schweizer Ständerates",
subtitle = "Gewichtet nach Menge der gemeinsamen Einsitze",
caption = "Quelle: lobbywatch.ch | Nodes = 35, Edges = 206")
}else{
plot <- ggnet2(network,
mode = mode,
color = "parlamentarier_partei",
palette = colors_party,
size = 7,
label = T,
label.alpha = .7,
vjust = -1,
legend.position = "bottom") +
labs(title = "Parlamentarisches Netzwerk des Schweizer Ständerates",
subtitle = "Gewichtet nach Menge der gemeinsamen Einsitze",
caption = "Quelle: lobbywatch.ch | Nodes = 35, Edges = 206")
}
return(plot)
}
network_gg(net_SR_2,"fruchtermanreingold", 0)
View(groupings)
View(parlamentarier)
View(ties_SR)
View(ties_SR_reduced)
View(net_SR_2)
View(parlamentarier)
library(tidyverse)
library(janitor)
library(data.table)
# Einlesen des Datensatzes
doc <- read_delim("Data/Lobbywatch/cartesian_minimal_parlamentarier_interessenbindung.csv",
delim = "\t")
# Wir interessieren uns nur die Ständerät:innen
doc_SR <- doc %>%
filter(parlamentarier_rat == "SR")
parlamentarier <- doc_SR %>%
select(parlamentarier_id,
parlamentarier_name,
parlamentarier_partei) %>%
group_by(parlamentarier_name) %>%
distinct(parlamentarier_id,
.keep_all = TRUE) %>%
arrange(parlamentarier_id) %>%
rename("id" = parlamentarier_id) %>%
rename("name" = parlamentarier_name)
groupings <- doc_SR %>%
select(parlamentarier_id,
organisation_id) %>%
mutate(parlamentarier_id = str_c(parlamentarier_id, "",
sep = "_")) %>% # Wird später gebraucht, um die einzelnen IDs wieder voneinander trennen zu können.
group_by(organisation_id, parlamentarier_id) %>%
distinct() %>%
summarise(sum = n())
setDT(groupings)
# N = Anahl geteilter Organisationsmitgliedschaften,
ties_SR <- groupings[groupings, on = "organisation_id", allow.cartesian = TRUE][parlamentarier_id<i.parlamentarier_id, .N, .(pair = paste0(parlamentarier_id, i.parlamentarier_id))]
# Erstellen eines tidy-Datensatzes
ties_SR <- ties_SR %>%
separate(pair,
into = c("from", "to"),
sep = "_") %>%
rename("weight" = N) %>%
arrange(desc(weight)) %>%
filter(weight >= 1) # Es werden nur Verbindungen zwischen Parlamentarier:innen verwendet, die in >= 5 gleichen Organisationen einsitzen.
# Die Gewichtung soll 01-normiert werden, damit sie einheitlicher dargestellt wird
ties_SR$weight <- (ties_SR$weight - min(ties_SR$weight)) /  (max(ties_SR$weight) - min(ties_SR$weight))
# Damit keine Null-Werte entstehend wird 0.05 zu diesen addiert
ties_SR$weight[ties_SR$weight == 0] <- ties_SR$weight[ties_SR$weight == 0] + 0.05
# Wir wollen keine Interparty-Edges, deshalb werden diese gelöscht.
# Interparty bedeutet: Personen in derselben Partei werden nicht als Edge dargestellt.
non_interparty <- c()
# Der Loop schaut, ob zwei Nodes mit einer Verbindung derselben Partei angehören. Falls ja, dann wird der Index
# des Paares einer Liste hinzugefügt. Diese Liste wird dann aus unserem Datensatz entfernt.
for(i in 1:nrow(ties_SR)){
from <- ties_SR$from[i]
to <- ties_SR$to[i]
if(parlamentarier[parlamentarier$id == from,3] == parlamentarier[parlamentarier$id == to,3]){
non_interparty <- append(non_interparty,i)
}
}
ties_SR_reduced <- ties_SR[-non_interparty,]
detach(package:data.table)
library(igraph)
library(statnet)
net_SR <- graph_from_data_frame(ties_SR_reduced)
net_SR <- as.undirected(
net_SR,
mode = "collapse",
edge.attr.comb = igraph_opt("edge.attr.comb")
)
net_SR_2 <-  as_tbl_graph(net_SR)
# Node-Attribute hinzufügen
net_SR_2 <- net_SR_2 %>%
activate(nodes) %>%
# Datentyp muss angepasst werden.
mutate(name = as.numeric(name)) %>%
left_join(parlamentarier,
by = c("name" = "id")) %>%
rename("id" = "name",
"name" = "name.y")
data(net_SR_2)
op <- par(mar = c(0,0,2,0), mfrow=c(1,2))
plot(net_SR_2, layout = layout.circle, main = "Circle", vertex.label=NA)
plot(net_SR_2, layout = layout.fruchterman.reingold, main='Fruchtermannreingold', vertex.label=NA)
par(op)
library(tidyverse)
library(janitor)
library(data.table)
# Einlesen des Datensatzes
doc <- read_delim("Data/Lobbywatch/cartesian_minimal_parlamentarier_interessenbindung.csv",
delim = "\t")
# Wir interessieren uns nur die Ständerät:innen
doc_SR <- doc %>%
filter(parlamentarier_rat == "SR")
parlamentarier <- doc_SR %>%
select(parlamentarier_id,
parlamentarier_name,
parlamentarier_partei) %>%
group_by(parlamentarier_name) %>%
distinct(parlamentarier_id,
.keep_all = TRUE) %>%
arrange(parlamentarier_id) %>%
rename("id" = parlamentarier_id) %>%
rename("name" = parlamentarier_name)
groupings <- doc_SR %>%
select(parlamentarier_id,
organisation_id) %>%
mutate(parlamentarier_id = str_c(parlamentarier_id, "",
sep = "_")) %>% # Wird später gebraucht, um die einzelnen IDs wieder voneinander trennen zu können.
group_by(organisation_id, parlamentarier_id) %>%
distinct() %>%
summarise(sum = n())
setDT(groupings)
# N = Anahl geteilter Organisationsmitgliedschaften,
ties_SR <- groupings[groupings, on = "organisation_id", allow.cartesian = TRUE][parlamentarier_id<i.parlamentarier_id, .N, .(pair = paste0(parlamentarier_id, i.parlamentarier_id))]
# Erstellen eines tidy-Datensatzes
ties_SR <- ties_SR %>%
separate(pair,
into = c("from", "to"),
sep = "_") %>%
rename("weight" = N) %>%
arrange(desc(weight)) %>%
filter(weight >= 3) # Es werden nur Verbindungen zwischen Parlamentarier:innen verwendet, die in >= 5 gleichen Organisationen einsitzen.
# Die Gewichtung soll 01-normiert werden, damit sie einheitlicher dargestellt wird
ties_SR$weight <- (ties_SR$weight - min(ties_SR$weight)) /  (max(ties_SR$weight) - min(ties_SR$weight))
# Damit keine Null-Werte entstehend wird 0.05 zu diesen addiert
ties_SR$weight[ties_SR$weight == 0] <- ties_SR$weight[ties_SR$weight == 0] + 0.05
# Wir wollen keine Interparty-Edges, deshalb werden diese gelöscht.
# Interparty bedeutet: Personen in derselben Partei werden nicht als Edge dargestellt.
non_interparty <- c()
# Der Loop schaut, ob zwei Nodes mit einer Verbindung derselben Partei angehören. Falls ja, dann wird der Index
# des Paares einer Liste hinzugefügt. Diese Liste wird dann aus unserem Datensatz entfernt.
for(i in 1:nrow(ties_SR)){
from <- ties_SR$from[i]
to <- ties_SR$to[i]
if(parlamentarier[parlamentarier$id == from,3] == parlamentarier[parlamentarier$id == to,3]){
non_interparty <- append(non_interparty,i)
}
}
ties_SR_reduced <- ties_SR[-non_interparty,]
detach(package:data.table)
library(igraph)
library(statnet)
net_SR <- graph_from_data_frame(ties_SR_reduced)
net_SR <- as.undirected(
net_SR,
mode = "collapse",
edge.attr.comb = igraph_opt("edge.attr.comb")
)
net_SR_2 <-  as_tbl_graph(net_SR)
# Node-Attribute hinzufügen
net_SR_2 <- net_SR_2 %>%
activate(nodes) %>%
# Datentyp muss angepasst werden.
mutate(name = as.numeric(name)) %>%
left_join(parlamentarier,
by = c("name" = "id")) %>%
rename("id" = "name",
"name" = "name.y")
data(net_SR_2)
op <- par(mar = c(0,0,2,0), mfrow=c(1,2))
plot(net_SR_2, layout = layout.circle, main = "Circle", vertex.label=NA)
plot(net_SR_2, layout = layout.fruchterman.reingold, main='Fruchtermannreingold', vertex.label=NA)
par(op)
library(tidyverse)
library(janitor)
library(data.table)
# Einlesen des Datensatzes
doc <- read_delim("Data/Lobbywatch/cartesian_minimal_parlamentarier_interessenbindung.csv",
delim = "\t")
# Wir interessieren uns nur die Ständerät:innen
doc_SR <- doc %>%
filter(parlamentarier_rat == "SR")
parlamentarier <- doc_SR %>%
select(parlamentarier_id,
parlamentarier_name,
parlamentarier_partei) %>%
group_by(parlamentarier_name) %>%
distinct(parlamentarier_id,
.keep_all = TRUE) %>%
arrange(parlamentarier_id) %>%
rename("id" = parlamentarier_id) %>%
rename("name" = parlamentarier_name)
groupings <- doc_SR %>%
select(parlamentarier_id,
organisation_id) %>%
mutate(parlamentarier_id = str_c(parlamentarier_id, "",
sep = "_")) %>% # Wird später gebraucht, um die einzelnen IDs wieder voneinander trennen zu können.
group_by(organisation_id, parlamentarier_id) %>%
distinct() %>%
summarise(sum = n())
setDT(groupings)
# N = Anahl geteilter Organisationsmitgliedschaften,
ties_SR <- groupings[groupings, on = "organisation_id", allow.cartesian = TRUE][parlamentarier_id<i.parlamentarier_id, .N, .(pair = paste0(parlamentarier_id, i.parlamentarier_id))]
# Erstellen eines tidy-Datensatzes
ties_SR <- ties_SR %>%
separate(pair,
into = c("from", "to"),
sep = "_") %>%
rename("weight" = N) %>%
arrange(desc(weight)) %>%
filter(weight >= 5) # Es werden nur Verbindungen zwischen Parlamentarier:innen verwendet, die in >= 5 gleichen Organisationen einsitzen.
# Die Gewichtung soll 01-normiert werden, damit sie einheitlicher dargestellt wird
ties_SR$weight <- (ties_SR$weight - min(ties_SR$weight)) /  (max(ties_SR$weight) - min(ties_SR$weight))
# Damit keine Null-Werte entstehend wird 0.05 zu diesen addiert
ties_SR$weight[ties_SR$weight == 0] <- ties_SR$weight[ties_SR$weight == 0] + 0.05
# Wir wollen keine Interparty-Edges, deshalb werden diese gelöscht.
# Interparty bedeutet: Personen in derselben Partei werden nicht als Edge dargestellt.
non_interparty <- c()
# Der Loop schaut, ob zwei Nodes mit einer Verbindung derselben Partei angehören. Falls ja, dann wird der Index
# des Paares einer Liste hinzugefügt. Diese Liste wird dann aus unserem Datensatz entfernt.
for(i in 1:nrow(ties_SR)){
from <- ties_SR$from[i]
to <- ties_SR$to[i]
if(parlamentarier[parlamentarier$id == from,3] == parlamentarier[parlamentarier$id == to,3]){
non_interparty <- append(non_interparty,i)
}
}
ties_SR_reduced <- ties_SR[-non_interparty,]
detach(package:data.table)
library(igraph)
library(statnet)
net_SR <- graph_from_data_frame(ties_SR_reduced)
net_SR <- as.undirected(
net_SR,
mode = "collapse",
edge.attr.comb = igraph_opt("edge.attr.comb")
)
net_SR_2 <-  as_tbl_graph(net_SR)
# Node-Attribute hinzufügen
net_SR_2 <- net_SR_2 %>%
activate(nodes) %>%
# Datentyp muss angepasst werden.
mutate(name = as.numeric(name)) %>%
left_join(parlamentarier,
by = c("name" = "id")) %>%
rename("id" = "name",
"name" = "name.y")
data(net_SR_2)
op <- par(mar = c(0,0,2,0), mfrow=c(1,2))
plot(net_SR_2, layout = layout.circle, main = "Circle", vertex.label=NA)
plot(net_SR_2, layout = layout.fruchterman.reingold, main='Fruchtermannreingold', vertex.label=NA)
par(op)
library(tidyverse)
library(janitor)
library(data.table)
set.seed(1234)
# Einlesen des Datensatzes
doc <- read_delim("Data/Lobbywatch/cartesian_minimal_parlamentarier_interessenbindung.csv",
delim = "\t")
# Wir interessieren uns nur die Ständerät:innen
doc_SR <- doc %>%
filter(parlamentarier_rat == "SR")
parlamentarier <- doc_SR %>%
select(parlamentarier_id,
parlamentarier_name,
parlamentarier_partei) %>%
group_by(parlamentarier_name) %>%
distinct(parlamentarier_id,
.keep_all = TRUE) %>%
arrange(parlamentarier_id) %>%
rename("id" = parlamentarier_id) %>%
rename("name" = parlamentarier_name)
groupings <- doc_SR %>%
select(parlamentarier_id,
organisation_id) %>%
mutate(parlamentarier_id = str_c(parlamentarier_id, "",
sep = "_")) %>% # Wird später gebraucht, um die einzelnen IDs wieder voneinander trennen zu können.
group_by(organisation_id, parlamentarier_id) %>%
distinct() %>%
summarise(sum = n())
setDT(groupings)
# N = Anahl geteilter Organisationsmitgliedschaften,
ties_SR <- groupings[groupings, on = "organisation_id", allow.cartesian = TRUE][parlamentarier_id<i.parlamentarier_id, .N, .(pair = paste0(parlamentarier_id, i.parlamentarier_id))]
# Erstellen eines tidy-Datensatzes
ties_SR <- ties_SR %>%
separate(pair,
into = c("from", "to"),
sep = "_") %>%
rename("weight" = N) %>%
arrange(desc(weight)) %>%
filter(weight >= 5) # Es werden nur Verbindungen zwischen Parlamentarier:innen verwendet, die in >= 5 gleichen Organisationen einsitzen.
# Die Gewichtung soll 01-normiert werden, damit sie einheitlicher dargestellt wird
ties_SR$weight <- (ties_SR$weight - min(ties_SR$weight)) /  (max(ties_SR$weight) - min(ties_SR$weight))
# Damit keine Null-Werte entstehend wird 0.05 zu diesen addiert
ties_SR$weight[ties_SR$weight == 0] <- ties_SR$weight[ties_SR$weight == 0] + 0.05
# Wir wollen keine Interparty-Edges, deshalb werden diese gelöscht.
# Interparty bedeutet: Personen in derselben Partei werden nicht als Edge dargestellt.
non_interparty <- c()
# Der Loop schaut, ob zwei Nodes mit einer Verbindung derselben Partei angehören. Falls ja, dann wird der Index
# des Paares einer Liste hinzugefügt. Diese Liste wird dann aus unserem Datensatz entfernt.
for(i in 1:nrow(ties_SR)){
from <- ties_SR$from[i]
to <- ties_SR$to[i]
if(parlamentarier[parlamentarier$id == from,3] == parlamentarier[parlamentarier$id == to,3]){
non_interparty <- append(non_interparty,i)
}
}
ties_SR_reduced <- ties_SR[-non_interparty,]
detach(package:data.table)
library(igraph)
library(statnet)
net_SR <- graph_from_data_frame(ties_SR_reduced)
net_SR <- as.undirected(
net_SR,
mode = "collapse",
edge.attr.comb = igraph_opt("edge.attr.comb")
)
net_SR_2 <-  as_tbl_graph(net_SR)
# Node-Attribute hinzufügen
net_SR_2 <- net_SR_2 %>%
activate(nodes) %>%
# Datentyp muss angepasst werden.
mutate(name = as.numeric(name)) %>%
left_join(parlamentarier,
by = c("name" = "id")) %>%
rename("id" = "name",
"name" = "name.y")
data(net_SR_2)
op <- par(mar = c(0,0,2,0), mfrow=c(1,2))
plot(net_SR_2, layout = layout.circle, main = "Circle", vertex.label=NA)
plot(net_SR_2, layout = layout.fruchterman.reingold, main='Fruchtermannreingold', vertex.label=NA)
par(op)
network_gg(net_SR_2,"fruchtermanreingold", 1)
network_gg(net_SR_2,"fruchtermanreingold", 0)
network_gg(net_SR_2,"fruchtermanreingold", 1)
library(statnet)
library(GGally)
library(ggpubr)
# Für den Plot werden die ofiziellen Parteifarben vergeben
# ggnet2 akzeptiert keine Hex-Codes, deshalb werden Annäherungen verwendet
colors_party = c("FDP" = "cornflowerblue",
"Grüne" = "chartreuse",
"M" = "darkorange",
"SP" = "brown1",
"SVP" = "chartreuse4")
# Funktion wird für die Reduktion von Redundanzen verwendet
network_gg <- function(network,mode,gewichtet){
if(gewichtet == 1){
plot <- ggnet2(network,
mode = mode,
color = "parlamentarier_partei",
palette = colors_party,
size = 7,
label = T,
label.alpha = .7,
vjust = -1,
edge.size = "weight",
legend.position = "bottom") +
labs(title = "Parlamentarisches Netzwerk des Schweizer Ständerates",
subtitle = "Gewichtet nach Menge der gemeinsamen Einsitze",
caption = "Quelle: lobbywatch.ch | Nodes = 35, Edges = 206")
}else{
plot <- ggnet2(network,
mode = mode,
color = "parlamentarier_partei",
palette = colors_party,
size = 7,
label = "<VertexName>",
label.alpha = .7,
vjust = -1,
legend.position = "bottom") +
labs(title = "Parlamentarisches Netzwerk des Schweizer Ständerates",
subtitle = "Gewichtet nach Menge der gemeinsamen Einsitze",
caption = "Quelle: lobbywatch.ch | Nodes = 35, Edges = 206")
}
return(plot)
}
network_gg(net_SR_2,"fruchtermanreingold", 0)
View(net_SR_2)
degree(net_SR_2)
degree(net_SR)
as_edgelist(net_SR)
degree(as_edgelist(net_SR))
parlamentarier %>%
mutate(degree = degree(net_SR))
degree(net_SR)
parlamentarier %>%
mutate(degree = degree(as_adjacency_matrix(net_SR)))
degree(as_adjacency_matrix(net_SR))
net_SR
as_adjacency_matrix(net_SR))
as_adjacency_matrix(net_SR)
degree(as_adjacency_matrix(net_SR))
degree(as.network(net_SR))
View(ties_SR_reduced)
net_SR_2
as.network(net_SR_2)
as.network(as.edgelist(net_SR_2))
net_SR
degree(net_SR)
degree(as.edgelist.matrix(net_SR))
as.edgelist.matrix(net_SR)
net_SR
as.edgelist(net_SR)
