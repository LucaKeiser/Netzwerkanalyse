---
title: "Aufgabenblatt zur Heimarbeit 2"
author: "Mirco Bazzani, Luca Keiser & Amir Shehadeh"
subtitle: 'Seminar: Methoden der sozialen Netzwerkanalyse'
output:
  word_document: default
  html_document:
    df_print: paged
  pdf_document: default
editor_options:
  chunk_output_type: console
---

## Aufgabenblatt zur Heimarbeit 3
### Methoden der sozialen Netzwerkanalyse


### Anhang R-Dokumente
## Datenbereinigung

Die folgenden Visualisierungen basieren auf den Ständeratsnetzwerken, welche in ersten beiden Heimarbeiten erstellt wurden (siehe Keiser, Shehadeh & Bazzani Heimarbeit 1 & 2). Kurz zusammengefasst stellen die Knoten die einzelnen Ständerät:innen. Die Kanten beziehen sich auf die gemeinsamen Mitgliedschaften in den jeweiligen Lobby-Organisationen. Alle Kanten des Graphen gelten dabei als ungerichtet, da wir davon ausgehen, dass sich die Personen jeweils gegenseitig kennen und wahrnehmen. Dieser Beziehung wird keine positive oder negative Konnotation zugewiesen. Die Kanten werden im Anschluss anhand der Anzahl gemeinsamer Einsitze gewichtet, wobei stärkere Verbindungen durch mehr gemeinsame Einsitze gekennzeichnet werden. In der letzten Arbeit haben wir und dafür entschieden, lediglich jene Knoten zu visualisieren, welche einen Betweenness-Score von mindestens fünf aufwiesen. Diese haben wir für die Visualisierungen der jetzigen Arbeit wieder entfernt. Dafür stellen wir nur noch Verbindungen zwischen Ständeräten dar, die nicht in der gleichen Partei tätig sind und vergleichen diese mit dem dichteren Netzwerk mit allen innerparteilicher Edges.   

```{r message=FALSE, warning=FALSE}
library(tidyverse)
library(tidygraph)
library(igraph)
library(ggraph)
library(janitor)
library(data.table)
library(knitr)
library(ggforce)


# Einlesen des Datensatzes
doc <- read_delim(here::here("Data", "Lobbywatch", "cartesian_minimal_parlamentarier_interessenbindung.csv"))

# Wir interessieren uns nur die Ständerät:innen
# Zudem möchten wir lediglich ihre ausserparteilichen Verbindungen
doc_SR <- doc %>% 
  filter(parlamentarier_rat == "SR") %>% 
  filter(organisation_rechtsform != "Parlamentarische Gruppe")
  

parlamentarier <- doc_SR %>% 
  select(parlamentarier_id, 
         parlamentarier_name, 
         parlamentarier_partei) %>% 
  mutate(parlamentarier_partei = case_when(
    is.na(parlamentarier_partei) ~ "Parteilos",
    TRUE ~ as.character(parlamentarier_partei))) %>% 
  group_by(parlamentarier_name) %>% 
  distinct(parlamentarier_id, 
           .keep_all = TRUE) %>% 
  arrange(parlamentarier_id) %>% 
  rename("id" = parlamentarier_id) %>% 
  rename("name" = parlamentarier_name)
```


```{r message=FALSE, warning=FALSE}
# Erstellen der Gruppen
groupings <- doc_SR %>% 
  select(parlamentarier_id,
         organisation_id) %>% 
  mutate(parlamentarier_id = str_c(parlamentarier_id, "",
                                   sep = "_")) %>% # Wird später gebraucht, um die einzelnen IDs wieder voneinander trennen zu können.
  group_by(organisation_id, parlamentarier_id) %>% 
  distinct() %>% 
  summarise(sum = n())

setDT(groupings)

# N = Anahl geteilter Organisationsmitgliedschaften. In diesem Schritt erstellen wir das Kantenattribut.
ties_SR <- groupings[groupings, on = "organisation_id", allow.cartesian = TRUE][parlamentarier_id<i.parlamentarier_id, .N, .(pair = paste0(parlamentarier_id, i.parlamentarier_id))]
```


```{r message=FALSE, warning=FALSE}
# Erstellen eines tidy-Datensatzes
ties_SR <- ties_SR %>% 
  separate(pair, 
           into = c("from", "to"), 
           sep = "_") %>% 
  rename("weight" = N) %>% 
  arrange(desc(weight))
  #filter(weight >= 5) # Es werden nur Verbindungen zwischen Parlamentarier:innen verwendet, die in >= 5 gleichen Organisationen einsitzen. 

# Wir wollen keine Intraparty-Edges, deshalb werden diese gelöscht.
# Intraparty bedeutet: Personen in derselben Partei werden nicht als Edge dargestellt.
non_interparty <- c()

# Der Loop schaut, ob zwei Nodes mit einer Verbindung derselben Partei angehören. Falls ja, dann wird der Index
# des Paares einer Liste hinzugefügt. Diese Liste wird dann aus unserem Datensatz entfernt.


for(i in 1:nrow(ties_SR)){
  
  from <- ties_SR$from[i]
  to <- ties_SR$to[i]
  if(parlamentarier[parlamentarier$id == from,3] == parlamentarier[parlamentarier$id == to,3]){
    non_interparty <- append(non_interparty,i)
  }
}

ties_SR_reduced <- ties_SR[-non_interparty,]



# erstellen eines Tibbles mit angepassten Datentypen
ties_SR <- ties_SR %>% 
  as_tibble() %>% 
  mutate(from = as.numeric(from),
         to = as.numeric(to))


ties_SR_reduced <- ties_SR_reduced %>% 
  as_tibble() %>% 
  mutate(from = as.numeric(from),
         to = as.numeric(to))

# Knoten
parlamentarier

# Kanten
ties_SR
ties_SR_reduced

```

```{r}
# erstellen des Netzwerkobjekts (tidygraph)
net_SR <- as_tbl_graph(ties_SR,
                       directed = FALSE) %>% 
  activate(nodes) %>% 
  mutate(id = as.numeric(name)) %>% 
  select(-name)


net_SR_reduced <- as_tbl_graph(ties_SR_reduced,
                       directed = FALSE)  %>% 
  activate(nodes) %>% 
  mutate(id = as.numeric(name)) %>% 
  select(-name)

```

## Masszahlen - gesamtes Netzwerk

Vergleich zwischen dem dichteren Netzwerk mitsamt innerparteilicher Edges und jenem, welches nur ausserparteiliche Edges darstellt.

Zuerst wurden die Masszahlen für Grösse, Dichte, Komponenten, Durchmesser und Clostering berechnet (Abb. 1). Beim Netzwerk handelt es sich jeweils um eine Komponente, auch wenn die innerparteilichen Edges wegfallen. Somit sehen wir, dass die Parlamentarier:innen überparteilich durch die Lobbyorganisationen miteinander verbunden sind. Die Dichte des Netzwerkes ist bei einem Score von 0.1022057 (ratiorange 0-1) eher gering. Je näher der Dichtewert bei 1 liegt, desto grösser ist die Netzwerkdichte und desto stärker sind die einzelnen Knoten miteinander verbunden (Luke 2015: 26). 

```{r}

# Generelle Netzwerkangaben
# Component
comp_sr <- count_components(net_SR)
comp_sr_red <- count_components(net_SR_reduced)
# Dichte
dens_sr <- edge_density(net_SR,
             loops = FALSE)
dens_sr_red <- edge_density(net_SR_reduced,
             loops = FALSE)
# Diameter
dia_sr <- diameter(net_SR,
         directed = FALSE)
dia_sr_red <- diameter(net_SR_reduced,
         directed = FALSE)

# Size
size_sr <- gsize(net_SR)
size_sr_red <- gsize(net_SR_reduced)

# Cliques
cliq_sr <- count_max_cliques(net_SR)
cliq_sr_red <- count_max_cliques(net_SR_reduced)

# Erstellen eines zusammenfassenden Dataframes für die Masszahlen
labels_df <- c("Components", "Density", "Diameter", "Size", "Cliques")

measurements_df <- data.frame(Measurement = labels_df,
           `With Intraparty Connections` = c(comp_sr,dens_sr,dia_sr,size_sr,cliq_sr),
           `Without Intraparty Connections` = c(comp_sr_red,dens_sr_red,dia_sr_red,size_sr_red,cliq_sr_red))

# Tidy Print
kable(measurements_df, caption = "Masszahlen der Netzwerke mit und ohne innerparteilicher Beziehungen")

```

## Masszahlen - Zentralitätsmasse Nodes
### Anhand des Netzwerks ohne innerparteilicher Beziehungen

```{r message=FALSE, warning=FALSE}
# hinzufügen der Knotenattribute
net_SR_reduced <- net_SR_reduced %>% 
  activate(nodes) %>%
  # Datentyp muss angepasst werden.
  left_join(parlamentarier,
            by = c("id"))


# Hinzufügen Zentralitätsmasse
net_SR_reduced <- net_SR_reduced %>% 
  activate(nodes) %>% 
  # Berechnung und standardisierung([0,1]) der Betweenness
  mutate(degree = centrality_degree(),
         betweenness = centrality_betweenness(),
         closeness = centrality_closeness())

# Extrahierung der relevanten Zeilen
masszahlen <- net_SR_reduced %>% 
  select(name,
         parlamentarier_partei,
         degree,
         betweenness,
         closeness) %>% 
  arrange(desc(degree))

# Tidy Print
kable(masszahlen)
```

## Identifizierung von Cutpoints

Die Cutpoints werden mit dem statnet-Paket identifitiert. Dazu muss zuerst ein network-Objekt erstellt werden. Hierzu wird ein etwas umstädlicher Workaround eingesetzt.

```{r}
library(statnet)

# erstellen temporärer Objekte zur Zwischenspeicherung

temp_1 <- ties_SR_reduced %>% 
  left_join(parlamentarier, by = c("from" = "id")) %>% 
  select(name, weight) %>% 
  rename("from"  = name)


temp_2 <- ties_SR_reduced %>% 
  left_join(parlamentarier, by = c("to" = "id")) %>% 
  select(name) %>% 
  rename("to"  = name)


network_ties_SR_reduced <- cbind(temp_1, temp_2) %>% 
  relocate(from, to, weight)


# löschen der temporären Objekte
rm(temp_1, temp_2)
gc()

# erstellen eines network-Objekts
network_SR_reduced <- network(network_ties_SR_reduced, 
                              type = "edgelist",
                              directed = FALSE)


# Identifizierung der Cutpoints
cutpoints_SR_reduced <- cutpoints(network_SR_reduced,
                                  # graph for undirected graphs
                                  mode = "graph",
                                  return.indicator = TRUE)

# insegsamt wurden 9 Cutpoints gefunden
table(cutpoints_SR_reduced)

# Visualisierung
set.seed(1234)
gplot(network_SR_reduced,
      gmode = "graph",
      vertex.col = cutpoints_SR_reduced+3,
      vertex.border = cutpoints_SR_reduced+3,
      vertex.cex = 0.7,
      edge.col = "grey90",
      jitter = FALSE,
      displaylabels = TRUE,
      label.cex = 0.7,
      label.pos = 5,
      main = "Cutpoints im reduzierten Netzwerk der Stände:rätinnen",
      )
```







## Cluster

```{r}

# Erstellen mehrerer Clusterings anhand dreier Algorithmen:
# Edge Betweenness, Fast Greedy & Infomap

cluster <- net_SR_reduced %>% 
  activate(nodes) %>% 
  mutate(group_edge_betweenness = group_edge_betweenness(),
         group_fast_greedy = group_fast_greedy(),
         group_infomap = group_infomap()) %>% 
  select(name,
         parlamentarier_partei,
         group_edge_betweenness,
         group_fast_greedy,
         group_infomap) %>% 
  arrange(group_edge_betweenness)

# Tidy Print
kable(cluster)

```

## Visualisierungen
### Netzwerkdarstellung mit Knoten- und Kantenattributen

```{r message=FALSE, warning=FALSE}
# Beachten: Um die Cluster darstellen zu können, muss das concaveman-Paket installiert werden
# install.packages("concaveman")

# Hinzufügen der Kantenattribute
set.seed(1245)

net_SR_reduced %>% 
  activate(nodes) %>% 
  mutate(group_fast_greedy = as.factor(group_fast_greedy())) %>% 
  ggraph(layout = "fr") + 
  geom_node_point(aes(color = parlamentarier_partei,
                      size = betweenness)) + 
  geom_node_text(aes(label = name),
                 repel = TRUE) +
  geom_edge_link(aes(width = weight),
                 show.legend = FALSE) +
  geom_mark_hull(aes(x = x, y = y, fill = group_fast_greedy, label = group_fast_greedy)) +
  scale_size(range = c(5, 15)) +
  scale_edge_width(range = c(0.1, 1)) + 
  scale_color_manual(values = c("FDP" = "cornflowerblue",
                                "Grüne" = "chartreuse2",
                                "M" = "darkorange",
                                "SP" = "brown1",
                                "SVP" = "chartreuse4",
                                "Parteilos" = "grey")) + 
  theme_graph() + 
  labs(title = "Ständerätliches Netzwerk anhand privater Organisationszugehörigkeit - Fruchtermannreingold",
       subtitle = "Knotenattribute: Namen, Parteizugehörigkeit und Betweenness-Score\nKantenattribute: gemeinsame Einsitze/Mitgliedschaften\nClustering: Fast & Greedy",
       color = "Partei",
       caption = "Es werden lediglich Beziehung zwischen Mitgleider:innen unterschiedlicher Parteien visualisiert")
```

