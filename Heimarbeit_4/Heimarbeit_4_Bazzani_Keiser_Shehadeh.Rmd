---
title: "Aufgabenblatt zur Heimarbeit 4"
author: "Luca"
date: '2022-05-26'
output: html_document
editor_options: 
  chunk_output_type: console
---

## Aufgabenblatt zur Heimarbeit 4
### Methoden der sozialen Netzwerkanalyse



## Anhang  - R-Code

```{r}
# Pakete laden
library(tidyverse)
library(tidygraph)
library(ggraph)
library(igraph)
library(knitr)
library(ggforce)

theme_set(theme_light())


# Einsatz meherer Prozessoren
doParallel::registerDoParallel(cores = 4)


# Datensatz laden
doc <- read_delim(here::here("Data", "Lobbywatch", "cartesian_minimal_parlamentarier_interessenbindung.csv"),
                  delim = "\t")

doc_SR <- doc %>% 
  filter(parlamentarier_rat == "SR") %>% 
  filter(organisation_rechtsform != "Parlamentarische Gruppe")
```


## Bipartites Netzwerk

```{r}
# Erstellen eines bipartiten Netzwerks anhand der Edgelist

# Edgelist (Parlamentarier:in und Organisation (Event))
edgelist <- doc_SR %>% 
  select(parlamentarier_name, organisation_name)



# ansehen
edgelist

edgelist %>% 
  count(parlamentarier_name,
        sort = TRUE)

edgelist %>% count(organisation_name, 
                   sort = TRUE)


# Bipartites Netzwerk
SR_bipartite_igraph <- graph.data.frame(edgelist,
                                        directed = TRUE)


# Noch nicht ganz...
SR_bipartite_igraph
list.vertex.attributes(SR_bipartite_igraph)

# Die Konten müssen noch differenziert werden (Parlamentarier:innen vs. Organisationen)
V(SR_bipartite_igraph)$name
edgelist[,1]
edgelist[,2]


V(SR_bipartite_igraph)$type <- V(SR_bipartite_igraph)$name %in% edgelist[,1]$parlamentarier_name


# Jetzt sieht es gut aus!
SR_bipartite_igraph
list.vertex.attributes(SR_bipartite_igraph)

# 45 Parlamentarier:innen und 636 Organisationen
table(get.vertex.attribute(SR_bipartite_igraph)$type)
```


## Knotenattribute

```{r}
# Hinzufügen weiterer Knotenattribute mit tidygraph
SR_bipartite_tidy <- as_tbl_graph(SR_bipartite_igraph)

# Definieren der Knotenattribute

# 1) Parlamentaier:innen
node_attributes_parl <- doc_SR %>% 
  select(parlamentarier_name, parlamentarier_geschlecht, parlamentarier_partei, parlamentarier_kanton) %>% 
  distinct()

# 2) Organisationen
node_attributes_org <- doc_SR %>% 
  select(organisation_name, organisation_ort, organisation_interessengruppe1, organisation_interessengruppe1_branche) %>% 
  distinct()

# Hinzufügen
SR_bipartite_tidy <- SR_bipartite_tidy %>% 
  
  # Knotenattribute (Parlamentarier)
  left_join(node_attributes_parl, 
            by = c("name" = "parlamentarier_name")) %>% 
  # Korrektur für Thomas Minder (Parteilos)
  mutate(parlamentarier_partei = ifelse(name == "Minder, Thomas", "Parleilos", parlamentarier_partei)) %>% 
  
  # Knotenattribute (Organisationen)
  left_join(node_attributes_org,
            by = c("name" = "organisation_name")) %>% 
  rename(sex = parlamentarier_geschlecht,
         party = parlamentarier_partei,
         canton = parlamentarier_kanton,
         location_org = organisation_ort,
         interest_org = organisation_interessengruppe1,
         industry_org = organisation_interessengruppe1_branche)


# aktualisieren des igraph-objekts
SR_bipartite_igraph <- as.igraph(SR_bipartite_tidy)

list.vertex.attributes(SR_bipartite_igraph)

# ansehen
SR_bipartite_tidy %>% 
  activate(nodes) %>% 
  as_tibble() %>% 
  group_by(type) %>% 
  slice_head(n = 10) 


tibble(
  name = V(SR_bipartite_igraph)$name,
  type = V(SR_bipartite_igraph)$type,
  sex = V(SR_bipartite_igraph)$sex,
  party = V(SR_bipartite_igraph)$party,
  canton = V(SR_bipartite_igraph)$canton,
  place = V(SR_bipartite_igraph)$location_org,
  interest = V(SR_bipartite_igraph)$interest_org,
  branche = V(SR_bipartite_igraph)$industry_org
) %>% 
  group_by(type) %>% 
  slice_head(n = 10)
```


## Grafiken


### Bipartites Netzwerk

```{r}
set.seed(12345)
SR_bipartite_tidy %>% 
  ggraph(layout = "fr") +
  geom_edge_link(color = "grey") + 
  geom_node_point(aes(shape = type,
                      color = type),
                  size = 5,
                  show.legend = FALSE) +
  geom_node_text(aes(label = name),
                 size = 2,
                 check_overlap = TRUE) + 
  labs(title = "Bipartites Netzwerk - Parlamentarier:innen und Organisationen",
       caption = "Aus Platzgründen werden nicht alle Namen angezeigt.")
```



### Projektionen

```{r}
# Projektionen
SR_projection <- bipartite.projection(SR_bipartite_igraph)
SR_projection

# 1) Organisationen
SR_organisationen_igraph <- SR_projection$proj1

# 2) Parlamentarier:innen
SR_parlamentarier_igraph <- SR_projection$proj2


# Gewichtung
get.adjacency(SR_organisationen_igraph,
              sparse = FALSE,
              attr = "weight")

get.adjacency(SR_parlamentarier_igraph,
              sparse = FALSE,
              attr = "weight")


# ansehen
# sehr spärlich...
table(E(SR_organisationen_igraph)$weight)
table(E(SR_parlamentarier_igraph)$weight)


# Grafiken werden mit tidygraph erstellt
SR_organisationen_tidy <- as_tbl_graph(SR_organisationen_igraph) %>% 
  mutate(degree = centrality_degree(),
         betweenness = centrality_betweenness(),
         closeness = centrality_closeness())
SR_parlamentarier_tidy <- as_tbl_graph(SR_parlamentarier_igraph) %>% 
  mutate(degree = centrality_degree(),
         betweenness = centrality_betweenness(),
         closeness = centrality_closeness())
```


```{r}
# Organisationsnetzwerk ist viel zu gross...
# Kann anhand meherer Kriterien gefiltert werden (Ort, Branche, Zentralitätsmasse etc.)
# Hier werden Kanten entfernt, welche eine Gewichtung <= 1 aufweisen. Das heisst, es werden nur 
# Organisationen berücksichtigt, welche sich mehr als 1 Parlamentarier:in "teilen"

# in einem ersten Schritt muss dazu ein Filterungsindex erstellt werden
index_org <- SR_organisationen_tidy %>%
  activate(edges) %>% 
  filter(weight > 1) %>% 
  as_tibble() %>% 
  select(from, to)

index_org <- c(index_org$from, index_org$to) %>% 
  unique()

set.seed(12345)
SR_organisationen_tidy %>%
  activate(edges) %>% 
  filter(weight > 1) %>% 
  activate(nodes) %>% 
  slice(index_org) %>% 
  ggraph(layout = "fr") +
  geom_edge_link(aes(width = weight),
                 alpha = 0.5,
                 show.legend = FALSE) +
  geom_node_point(aes(color = industry_org,
                      size  = degree)) +
  geom_node_text(aes(label = name),
                 repel = TRUE,
                 size = 3) +
  scale_edge_width(range = c(0.2, 0.8)) +
  scale_size(range = c(1, 6)) + 
  labs(title = "Organisationsnetzwerk - Geteilte Parlamentarier:innen",
       subtitle = "Je breiter die Kanten, desto mehr Parlamentarier:innen 'teilen' sich die Organisationen",
       size = "Degree",
       color = "Branche",
       caption = "Organisationen mit einer Gewichtung von <= 1 wurden herausgefiltert.")
```


```{r}
# Parlamentarier:innen
set.seed(12345)
SR_parlamentarier_tidy %>% 
  ggraph(layout = "fr") +
  geom_edge_link(aes(width = weight),
                 color = "grey",
                 show.legend = FALSE) + 
  geom_node_point(aes(color = party,
                      size = degree)) +
  geom_node_text(aes(label = name),
                 size = 4,
                 repel = TRUE) + 
  scale_color_manual(values = c("FDP" = "cornflowerblue", 
                                "Grüne" = "chartreuse2", 
                                "M" = "darkorange", 
                                "SP" = "brown1", 
                                "SVP" = "chartreuse4", 
                                "Parteilos" = "grey")) + 
  scale_edge_width(range = c(0.5, 1)) + 
  scale_size(range = c(4, 10)) + 
  labs(title = "Ständerätliches Netzwerk - Gemeinsame Einsitze in Organisationen",
       subtitle = "Je breiter die Kanten, desto mehr Organisationen 'teilen' sich die Parlamentarier:innen",
       size = "Degree",
       color = "Partei")
```



# Community Detection

## Communities: Parlamentarier:innen

Die Community Detection wird sowohl auf die Parlamentarier:innen als auch das Organisationsnetzwerk angewendet. Basierend auf Douglas A. Lukes Methode (siehe Luke 2015: 118) versuchen wir in einem ersten Schritt den Algorithmus zu finden, welcher den höchsten Modularitätswert vorweist. 

Im Falle der Parlamentarier:innen wäre dies *Louvian*.

```{r}

## Auswahl des Algorithmus mit der besten Modularität für das Parlamentarier:innen-Netzwerk

# Fast & Greedy
fg_p <- modularity(
  cluster_fast_greedy(SR_parlamentarier_tidy)
  )

# Infomap
in_p <- modularity(
  cluster_infomap(SR_parlamentarier_tidy)
  )

# Edge Betweenness
eb_p <- modularity(
  cluster_edge_betweenness(SR_parlamentarier_tidy)
  )

# Louvian
lv_p <- modularity(
  cluster_louvain(SR_parlamentarier_tidy)
  )


## Dataframe
Algorithm <- c("Fast & Greedy",
               "Infomap",
               "Edge Betweenness",
               "Louvian")

Modularity <- c(fg_p,
                in_p,
                eb_p,
                lv_p )

kable(data.frame(Algorithm,Modularity),
      caption = "Tabelle 1: Modularity Scores des Parlamentarier:innen-Netzwerks basierend auf verschiedenen Community-Algorithmen")
```

Wendet man den Algorithmus auf das Netzwerk an, so werden insgesamt sieben verschiedene Communities identifiziert. Zwei dieser sieben lasssen sich dadurch erklären, dass sie atomisierte und innerhalb des Netzwerkes nicht verbundene Politiker:innen darstellen (Community 6 und 7).

Communities 1 und zwei weisen eine starke Überschneidung auf und hier sind keine klaren Parteimuster zu erkennen. Gerade in Community 2 sind die Parteien mit vier Grünen und jeweils drei Politiker:innen der SP und SVP relativ ausgeglichen. 

Spannender wird die identifizierte Community 3, welche aussschliesslich aus FDP und Mitte-Politiker:innen besteht und somit ein klares mitte-rechts-Bias besitzt.


```{r}
# Parlamentarier:innen - Community
set.seed(12345)
SR_parlamentarier_tidy %>% 
  mutate(group_louvain= as.factor(group_louvain())) %>% 
  ggraph(layout = "fr") +
  geom_edge_link(aes(width = weight),
                 color = "grey",
                 show.legend = FALSE) + 
  geom_node_point(aes(color = party,
                      size = degree)) +
  geom_node_text(aes(label = name),
                 size = 4,
                 repel = TRUE) + 
  geom_mark_hull(aes(x = x, 
                     y = y, 
                     fill = group_louvain, 
                     label = group_louvain),
                 concavity = 6) +
  scale_color_manual(values = c("FDP" = "cornflowerblue", 
                                "Grüne" = "chartreuse2", 
                                "M" = "darkorange", 
                                "SP" = "brown1", 
                                "SVP" = "chartreuse4", 
                                "Parteilos" = "grey")) + 
  scale_edge_width(range = c(0.5, 1)) + 
  scale_size(range = c(4, 10)) + 
  labs(title = "Ständerätliches Netzwerk - Gemeinsame Einsitze in Organisationen | Communities",
       subtitle = "Communities anhand Algorithmus Louvian ausgearbeitet",
       size = "Degree",
       color = "Partei")
```

## Communities: Organisationen

Wesentlich spannender und eindeutiger gestaltet sich die Community Detection bei den Organisationen. Alle verwendeten Algorithmen kommen hier auf ähnliche Modularitätswert. Der Einfachheit und Vergleichbarkeit halber wurde auch hier der *Louvian*-Algorithmus weitervwerendet.

```{r}

## Auswahl des Algorithmus mit der besten Modularität für das Parlamentarier:innen-Netzwerk
SR_organisationen_tidy_com <- SR_organisationen_tidy %>%
  activate(edges) %>% 
  filter(weight > 1)

# Fast & Greedy
fg_o <- modularity(
  cluster_fast_greedy(SR_organisationen_tidy_com)
  )

# Infomap
in_o <- modularity(
  cluster_infomap(SR_organisationen_tidy_com)
  )

# Edge Betweenness
eb_o <- modularity(
  cluster_edge_betweenness(SR_organisationen_tidy_com)
  )


# Louvian
lv_o <- modularity(
  cluster_louvain(SR_organisationen_tidy_com)
  )

## Dataframe
Algorithm <- c("Fast & Greedy",
               "Infomap",
               "Edge Betweenness",
               "Louvian")

Modularity <- c(fg_o,
                in_o,
                eb_o,
                lv_o)

kable(data.frame(Algorithm,Modularity),
      caption = "Tabelle 2:Modularity Scores des Organisationsnetzwerks basierend auf verschiedenen Community-Algorithmen")
```


Insgesamt konnten 12 distinkte Communities Identifiziert werden. Darunter das primär wirtschaftlich geprägte Netzwerk um die Universität Zürich (Community 1), das ostschweizerische Netzwerk um die Universität St.Gallen (Community 2), Sport und Freizeit in Community 3, Politische Inklusion mit einem Flavour von Ökologie in Community 5, die Glarner Comminity in Community 6, das Zentralschweizer Netz in Community 7, Umwelt und Verkehr in Communities 8 und 9.

Communities 4, 10, 11 und 12 konnten nicht klar identifiziert werden, eine Übersicht findet sich in der Tabelle 3



```{r}
# Organisationen - Community
set.seed(12345)

SR_organisationen_tidy_com  %>% 
  activate(nodes) %>% 
  slice(index_org) %>% 
  mutate(group_louvain= as.factor(group_louvain())) %>% 
  ggraph(layout = "fr") +
  geom_edge_link(aes(width = weight),
                 alpha = 0.5,
                 show.legend = FALSE) +
  geom_node_point(aes(color = industry_org,
                      size  = degree)) +
  geom_node_text(aes(label = name),
                 repel = TRUE,
                 size = 3) +
   geom_mark_hull(aes(x = x, 
                     y = y, 
                     fill = group_louvain, 
                     label = group_louvain),
                 concavity = 6) +
  scale_edge_width(range = c(0.2, 0.8)) +
  scale_size(range = c(1, 6)) + 
  labs(title = "Organisationsnetzwerk - Geteilte Parlamentarier:innen",
       subtitle = "Je breiter die Kanten, desto mehr Parlamentarier:innen 'teilen' sich die Organisationen",
       size = "Degree",
       color = "Branche",
       caption = "Organisationen mit einer Gewichtung von <= 1 wurden herausgefiltert.")
```


```{r}
Communities <- c()

for(i in 1:12){
  text <- paste("Community ", as.character(i))
  Communities <- append(Communities, text)
}

Kategorie <-  c("Wirtschaft Zürich",
            "Ostschweizer Netzwerk",
            "Sport und Freizeit",
            "-",
            "Politische Inklusion und Ökologie",
            "Glarner Community",
            "Zentralschweizer Netz",
            "Umwelt und Verkehr",
            "Umwelt und Verkehr",
            "-",
            "-",
            "-")

kable(as.data.frame(Communities, Kategorie),
      caption = "Tabelle 3: Interpretation der Communities im organisationalen Netzwerk")
```

